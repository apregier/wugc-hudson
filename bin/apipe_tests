#!/usr/bin/env perl

use warnings;
use strict;

use above 'Genome';
use above 'UR';

BEGIN {
    require Cwd;
	require File::Basename;
    my $lib_dir = Cwd::abs_path(File::Basename::dirname(__FILE__) . '/../lib/');
    unless (grep { $lib_dir eq Cwd::abs_path($_) } @INC) {
        push @INC, $lib_dir;
    }
}

use Users;
use Library;


my $LOOP_SLEEP_MINS = 1;
my $TIMEOUT_HOURS = $ENV{JENKINS_TIMEOUT_HOURS} || 30;

$ENV{UR_COMMAND_DUMP_STATUS_MESSAGES} = 1;

my ($model_name, $software_revision);
if (@ARGV) {
    $model_name = $ARGV[0] || die;
    $software_revision = $ARGV[1];
}

my @builds_started;
if ($software_revision) {
    my @builds = Genome::Model::Build->get(
        model_name => $model_name,
        run_by => 'apipe-tester',
        'software_revision like' => "%$software_revision%",
        status => ['Running', 'Failed', 'Scheduled', 'Succeeded'],
    );
    if (@builds) {
        my $build = $builds[-1];
        my $status = $build->status;
        if ($status && $status eq 'Succeeded') {
            print "Successful build already exists for $software_revision.\n";
            exit;
        }
        elsif ($status && $status eq 'Running') {
            print "Using already running build " . $build->__display_name__ . ".\n";
            @builds_started = @builds;
        }
    }
    else {
        print STDERR "No builds found for software_revision = $software_revision, starting new build.\n";
    }
}

my $build_start_command;
unless (@builds_started) {
    my %model_params;
    if ($model_name) {
        $model_params{name} = $model_name;
    } else {
        $model_params{'name like'} = 'apipe-tests%';
    }
    my @models = Genome::Model->get(%model_params);
    $build_start_command = Genome::Model::Build::Command::Start->create(
        models => \@models,
        force => 1,
    );
}

if ($build_start_command) {
    my $build_start_rv = $build_start_command->execute;
    die "Could not execute build_start_command!" unless defined $build_start_rv and $build_start_rv == 1;

    my $commit_rv = UR::Context->commit;
    die "Could not commit changes!" unless defined $commit_rv and $commit_rv == 1;

    @builds_started = $build_start_command->builds;
}

unless (@builds_started) {
    die "No builds to monitor!\n";
}


# Get information about builds and master events for monitoring
my %builds;
for my $build (@builds_started) {
    $builds{$build->id} = $build;
}
my %build_master_events;
foreach my $build (values %builds) {
    $build_master_events{$build->build_id} = $build->the_master_event->id;
}

my @build_ids = sort keys %builds;

# Print out information about the builds that were started so they're recorded in the Hudson raw output
print "\n\nBuilds started for models, waiting for them to finish:\n";
for my $build_id (sort keys %builds) {
    my $build = $builds{$build_id};
    my $model = $build->model;
    my $type_string = Library::model_class_name_to_string($model->class);
    print "\tbuild $build_id ($type_string), model " . $model->id . " (" . $model->name . ")\n";
}
print "\n";

# Record current status of each build, continue until no builds are running or the timeout limit is reached
my %failures;
my %others;
my %successes;
my ($all_done, $total_wait_time) = (0,0);
while (!$all_done) {
    $total_wait_time++;
    sleep (60 * $LOOP_SLEEP_MINS);

    # Record status of each build, count number of running builds
    my $running = 0;
    %failures = ();
    %others = ();
    %successes = ();
    foreach my $build_id (@build_ids) {
        my $build = UR::Context->current->reload("Genome::Model::Build", id=>$build_id);
        my $event = UR::Context->current->reload("Genome::Model::Event", id=>$build_master_events{$build_id});
        if ($event->event_status =~ /Failed/ or $event->event_status =~ /Crashed/) {
            $failures{$build->id} = $event->event_status;
        } elsif ($event->event_status =~ /Succeeded/) {
            $successes{$build->id} = $event->event_status;
        } elsif ($event->event_status =~ /Running/ or $event->event_status =~ /Scheduled/) {
            $running++;
            $others{$build_id} = $event->event_status;
        } else {
            $others{$build->id} = $event->event_status;
        }
    }
    $all_done = 1 if $running == 0;

    # Just so we know that the script hasn't gone belly up, and lets us know how many builds we're waiting on
    if ($total_wait_time % 10 == 0) {
        print "Waited $total_wait_time minutes for builds to finish, $running of " . scalar @build_ids . " are still running\n";
    }

    # Time to die, send email and exit
    if ($total_wait_time > ($TIMEOUT_HOURS * 60)) {
        print "Timeout period exceeded, sending email and dying!\n";

        my $msg = "The test builds have been running for more than $TIMEOUT_HOURS hours, which has been set as the timeout period. " .
            "Here are the statuses of all of the builds:\n";
        for my $hash (\%successes, \%failures, \%others) {
            for my $build_id (sort keys %{$hash}) {
                my $build = $builds{$build_id};
                my $model = $build->model;
                my $type_string = Library::model_class_name_to_string($build->model->class);
                $msg .= "Build $build_id (type $type_string), Model " . $model->id . " (" . $model->name . ") : " . $hash->{$build_id} . "\n";
                my @to;
                my @cc;
                if (Users->can($type_string)) {
                    @to = Users->$type_string;
                    @cc = Users::apipe();
                } else {
                    @to = Users::apipe();
                    @cc = '';
                }

                Library::send_mail(
                    from => 'apipe-tester@genome.wustl.edu',
                    to => Library::users_to_addresses(@to),
                    cc => Library::users_to_addresses(@cc),
                    subject => "[fail] Build Test Timed Out! ($type_string)",
                    body => $msg,
                );
            }
        }

        exit 1;
    }
}

print "Builds are done, checking statuses and sending failure emails (if necessary)\n";

# Send email to build owners and cc apipe (or just send to apipe if no owners for type are found) for every failure
if (scalar keys %failures or scalar keys %others) {
    for my $hash (\%failures, \%others) {
        for my $key (sort keys %{$hash}) {
            my $build = $builds{$key}; 
            my $model = $build->model;
            my $status = $hash->{$key};
            my $type_string = Library::model_class_name_to_string($build->model->class);

            print "Build $key, type $type_string, failed (status $status), sending mail\n";

            my $build_url = "https://imp.gsc.wustl.edu/view/Genome/Model/Build/status.html?id=$key";
            my $msg = "Test build $key of type $type_string finished with status $status! Model is " . $model->id . " (" . $model->name . ").\n\n" . 
                "Check out the status page at $build_url and fix it!\n";
            
            my @to;
            my @cc;
            if (Users->can($type_string)) {
                @to = Users->$type_string;
                @cc = Users::apipe();
            } else {
                @to = Users::apipe();
                @cc = '';
            }

            Library::send_mail(
                from => 'apipe-tester@genome.wustl.edu',
                to => Library::users_to_addresses(@to),
                cc => Library::users_to_addresses(@cc),
                subject => "[fail] test build $key failed, type $type_string",
                body => $msg,
            );
        }
    }
    exit 1;
}
else {
    print "No test build failures found!\n";
    exit 0;
}

1;
