#!/gsc/bin/perl

use strict;
use warnings;
use File::Basename;
use Getopt::Long;
use MIME::Lite;
use Cwd;
use above 'Genome';
use above 'UR';

BEGIN {
    require Cwd;
    require File::Basename;
    my $lib_dir = Cwd::abs_path(File::Basename::dirname(__FILE__) . '/../lib/');
    unless (grep { $lib_dir eq Cwd::abs_path($_) } @INC) {
        unshift @INC, $lib_dir;
    }
}

require Users;
require Library;

## If run by Jenkins, this environment variable should be set
my $jenkins_build_number = $ENV{BUILD_NUMBER} || "'manual build'";
my $jenkins_build_url = $ENV{BUILD_URL} || "'no URL - manual build'";

my $model_name;
my $pipeline_version;
my $ref_sw_revision;
my $sw_revision;
my $send_emails;

eval {
    my $r = GetOptions("model-name=s" => \$model_name,
                       "pipeline-version=s" => \$pipeline_version,
                       "ref-sw-revision=s" => \$ref_sw_revision,
                       "sw-revision=s" => \$sw_revision,
                       "send-emails" => \$send_emails,
                       "help" => \&help_and_exit,
                       );

    help_and_exit() unless $r;

    die "Model name not set" unless $model_name;
    my $model = Genome::Model->get(name => $model_name);
    die "Model $model_name not found" unless $model;
    print "Using model: " . $model->id . "\n";
    
    init_versions();
    my ($ref_build, $cur_build) = get_builds($model);
    print "Comparing build " . $ref_build->id . " using revision $ref_sw_revision\n" . 
          "     with build " . $cur_build->id . " using revision $sw_revision\n";

    my %diffs = $cur_build->compare_output($ref_build->build_id);
    unless (%diffs) {
        print "All files and metrics diffed cleanly!\n";
        exit 0;
    }
    else {
        my $diff_string = "DIFFERENCES FOUND $model_name ".$model->id."\n";
        for my $file (sort keys %diffs) {
            my $reason = $diffs{$file};
            $diff_string .= "  File: $file, Reason: $reason\n";
        }
        print "$diff_string\n";

        send_owner_emails($model, $diff_string);
        print "Differences or errors encountered, please review and/or fix!\n";
        exit 1;
    }
};
if ($@) {
    my $error = $@;
    print "Error: $error";
    send_apipe_tester_emails($error);
    exit 1;
}

sub help_and_exit {
    my ($ret_val) = @_;
    my $filename = basename(__FILE__);
    print <<EOS;
Usage: $filename [options] --model_name=name_of_model

Options:
    --model-name=           name of model
    --pipeline-version=     git tag like 'genome-1130'
    --ref-sw-revision=      software_revision of build to diff against
    --sw-revision=          software_revision of build to diff
    --send-emails           send emails on failures
    --help                  prints this message

Description:
    If ref-sw-revision is not set, pipeline-version will be used to try to
    retrieve the version from git. If pipeline-version is not set it will
    be read from the PIPELINE_VERSION env var. If sw-revision is not set
    it is retrieved as the current hash of the git repo (assuming you're in one).

EOS
    exit 1;
}

sub get_model_camel_type {
    my ($model) = shift;
    my $type = $model->class;
    $type =~ s/Genome::Model:://;
    return Genome::Utility::Text::camel_case_to_string($type, '_');
}

sub get_builds {
    my ($model) = @_;
    
    my @ref_builds = $model->builds(software_revision => $ref_sw_revision);
    die "Expecting one build with software_revision=$ref_sw_revision, got " . @ref_builds unless @ref_builds == 1;
    my $ref_build = $ref_builds[0];
    
    my @cur_builds = $model->builds(software_revision => $sw_revision);
    die "Expecting one build with software_revision=$sw_revision, got " . @cur_builds unless @cur_builds == 1;
    my $cur_build = $cur_builds[0];

    return $ref_build, $cur_build;
}

sub init_versions {
    unless ($sw_revision) {
        $sw_revision = `git rev-parse --short HEAD`;
        die "Could not get current hash from git" unless $sw_revision;
        chomp $sw_revision;
    }

    unless ($ref_sw_revision) {
        unless ($pipeline_version) {
            $pipeline_version = $ENV{PIPELINE_VERSION};
            die "\$PIPELINE_VERSION not defined" unless $pipeline_version;
            chomp $pipeline_version;
        }
        
        $ref_sw_revision = `git rev-parse --short $pipeline_version`;
        die "No reference version available for $pipeline_version" unless $ref_sw_revision;
        chomp $ref_sw_revision;
    }
}

sub send_apipe_tester_emails {
    my ($errors) = @_;
    return unless ($send_emails);

    my $failure_msg_body = "Jenkins diff build $jenkins_build_number failed to execute!\n" .
                           "To see raw output, go to $jenkins_build_url\n" .
                           "Errors: " . $errors;
                           
    Library::send_mail(
        subject => '[fail] Test Build Diff Failed to Execute!', 
        body => $failure_msg_body,
        from => 'apipe-tester@genome.wustl.edu',
        to => Library::users_to_addresses(Users::apipe()),
    );
}

sub send_owner_emails {
    my ($model, $diff_string) = @_;
    return unless ($send_emails);

    my $build_type = get_model_camel_type($model);
    my @to = (Users->can($build_type)) ? Users->$build_type : Users::apipe();
    my @cc = Users::apipe();

    my $model_id = $model->id;
    my $failure_msg = "Output differences detected when comparing builds of type $build_type from model $model_id\n" .
        "Diff output:\n$diff_string\n" .
        "To see raw output, go to $jenkins_build_url.";
    my $failure_subject = "[fail] differences found, model $model_id, $build_type - " . join(",", @to);

    Library::send_mail(
        to => Library::users_to_addresses(@to),
        from => 'apipe-tester@genome.wustl.edu',
        cc => Library::users_to_addresses(@cc),
        subject => $failure_subject,
        body => $failure_msg,
    );
}

