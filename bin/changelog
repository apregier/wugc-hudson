#!/usr/bin/env perl

use strict;
use warnings;
use Data::Dumper;

BEGIN {
    require Cwd;
	require File::Basename;
    my $lib_dir = Cwd::abs_path(File::Basename::dirname(__FILE__) . '/../lib/');
    unless (grep { $lib_dir eq Cwd::abs_path($_) } @INC) {
        push @INC, $lib_dir;
    }
}

require Defaults;


#genome-250 genome-388
my ($rev1, $rev2) = @ARGV;
die "Whoops! Try: $0 [REV1] [REV2]" if !$rev1 || !$rev2;
die "Error: rev1 and rev2 are both $rev1" if $rev1 eq $rev2;

my $git_repo = Defaults::GIT_REPOS_BASE() . '/genome/lib/perl';
my $rev = join('..',$rev1, $rev2);
chomp(my $git_has_rev1 = qx(cd $git_repo && git tag -l | grep $rev1));
chomp(my $git_has_rev2 = qx(cd $git_repo && git tag -l | grep $rev2));
unless ($git_has_rev1 && $git_has_rev2) {
	qx(cd $git_repo && git reset --hard HEAD && git pull);
}
my $c = qx[cd $git_repo && git log --pretty="format:JAGVILLSOVA%h	%ce	%s	%b " $rev];
if ($?) {
	die "Failed to get log from git.\n";
}

my $now = localtime();

my @lines = split(/JAGVILLSOVA/,$c);
my $i;
for my $l (@lines) {

    next if $i++ == 0;
    my ($hash, $email, $subj, $body) = split(/\t/,$l);
    chomp($body);

    my $r = {
        hash  => $hash,
        email => $email,
        subj  => $subj,
        body  => $body,
    };

    my @log;
    if ($subj =~ /CHANGELOG:\s*(.*)/) {
        push @log, $1;
    }

    if ($body =~ /CHANGELOG:/) {

        if ($body =~ /CHANGELOG:(.*?)\n*^\s*$/ms) {
            push @log, $1; 
        } else {
            $body =~ /CHANGELOG:(.*)\n/ms;
            push @log, $1;
        }
    }

    if (@log > 0) {
        $r->{'log'} = \@log;
        print_log_entry($r);
    }
}

exit;


sub print_log_entry {

    my ($r) = @_;

    my $log = join('', @{$r->{'log'}});
    printf("%s\n%s (%s)\n\n", $log, $r->{'email'}, $r->{'hash'});
}

