#!/usr/bin/env perl

use strict;
use warnings;

use XML::Simple;
use Data::Dumper;

use Mail::Sendmail;

BEGIN {
	require File::Basename;
	push @INC, File::Basename::dirname(__FILE__) . '/../lib/';
}
use Users;
require Defaults;
require Cwd;
require Mail::Sender;

my @xml_files = qx[find test_results -name '*.junit.xml'];
map { chomp $_ } @xml_files;
for my $xml_file (@xml_files) {
    my $xml = XMLin($xml_file) || die "failed to parse junit results xml file: $xml_file";
    my $testsuite = $xml->{'testsuite'};
    next unless ($testsuite->{failures} || $testsuite->{errors});
    print $testsuite->{name} . "\n";
    send_alert($testsuite);
}

exit;

sub get_revision_info {
    my $workspace_base = Defaults::HUDSON_CUSTOM_WORKSPACE();
    my $cwd = Cwd::cwd();

    my @namespaces;
    if ($cwd =~ /genome/) {
        push @namespaces, ('ur', 'workflow', 'genome');
    } elsif ($cwd =~ /workflow/) {
        push @namespaces, ('ur', 'workflow');
    } elsif ($cwd =~ /ur/) {
        push @namespaces, 'ur';
    } else {
        die "Unexpected CWD ($cwd) does not match genome/workflow/ur.\n";
    }

    my @revisions;
    for my $namespace (@namespaces) {
        my $git_out = qx[cd $workspace_base/$namespace && git log --oneline | head -n 1];
        push @revisions, "$namespace: " . (split(' ', $git_out))[0];
    }

    return @revisions;
}

sub message_body {
    my $testsuite = shift;
    my $name = $testsuite->{name};
    my $failure_count = $testsuite->{failures};
    my $error_count = $testsuite->{errors};
    my $system_err = $testsuite->{'system-err'}; chomp $system_err;
    my $system_out = $testsuite->{'system-out'}; chomp $system_out;
    my $error = $testsuite->{error}{message}; chomp $error;

    my $testcases = $testsuite->{testcase};
    if (exists $testcases->{time}) {
        my $test_name = delete $testcases->{name};
        $testcases = {$test_name => $testcases};
    }
    my @failed_tests;
    for my $test (keys %{$testcases}) {
        push @failed_tests, $test if ($testcases->{$test}{failure});
    }

    my $message_body;

    if ($failure_count) {
        $message_body .= "\nFailures ($failure_count):\n";
        map { $message_body .= $testcases->{$_}{message} . "\n"; } @failed_tests;
    }

    if ($error_count) {
        $message_body .= "\nErrors ($error_count):\n";
        $message_body .= "$error\n";
    }

    my @revisions = get_revision_info();
    my $hudson_url = $ENV{BUILD_URL} || 'unknown';
    $message_body .= "\nInfo:\n";
    $message_body .= join("\n", @revisions) . "\n";
    $message_body .= "hudson url: $hudson_url\n";

    if (not ref $system_err) {
        $message_body .= "\n++++system err++++\n";
        $message_body .= truncate_over_4k($system_err) . "\n";
        $message_body .= "----system err----\n";
    }

    if (not ref $system_out) {
        $message_body .= "\n++++system out++++\n";
        $message_body .= truncate_over_4k($system_out) . "\n";
        $message_body .= "----system out----\n";
    }

    return $message_body;
}

sub truncate_over_4k {
    my $text = shift;
    my $max_bytes = 4096;
    my $length  = length($text);
    if ($length > $max_bytes) {
        $text  = substr($text, $length - $max_bytes); # truncate output
        $text .= "Output was truncated because it was too large. Visit the hudson URL above for the full output.";
    }
    return $text;
}

sub send_alert {
    my $testsuite = shift;
    
    my $path = $testsuite->{name};
    $path =~ s/_/\//g;
    $path =~ s/\/t$/.t/;
    
    my ($to, $cc, $names) = git_blame($path);
    my $mail_to = join(',', @$to);
    my $mail_cc = join(',', @$cc);
    my $mail_subject = "[fail] $path - " . join(', ', @$names);
    my $mail_msg = message_body($testsuite);

    my $user_name = getpwuid($<);
    my $mail_from = $user_name . '@genome.wustl.edu';

    my $sender = Mail::Sender->new({
        smtp => 'gscsmtp.wustl.edu',
        from => $mail_from,
    });
    if (my $debug_email = $ENV{DEBUG_EMAIL_FAILURES}) {
        $mail_msg = "To: $mail_to\nCC: $mail_cc\n" . $mail_msg;
        $sender->MailMsg({
            to => $debug_email,
            subject => $mail_subject,
            msg     => $mail_msg,
        });
    } else {
        $sender->MailMsg({
            to => $mail_to,
            cc => $mail_cc,
            subject => $mail_subject,
            msg     => $mail_msg,
        });
    }
    return 1;
};

sub git_blame {

    my ($test_pathname) = @_;
    my @winners;
    my @winners_without_decoration;

    my @rest;

    my @us = map { $_ . '@genome.wustl.edu' } Users::apipe();

    my @ignore = Users::apipe_ignore();
    $test_pathname = "lib/perl/Genome/$test_pathname";

    my $module_pathname = $test_pathname;
    $module_pathname =~ s/\.t$/.pm/;

    # returns the editor with last commit, most commits, and random apiper
    
    # 1. last commit
	my $log_cmd;
	if ( -e $module_pathname ) {
		$log_cmd = "git log -- $module_pathname";
	} elsif ( -e $test_pathname ) {
		$log_cmd = "git log -- $test_pathname";
	} else {
        print STDERR "Could not find module or test:\n$module_pathname\n$test_pathname\n";
    }
    my @log_out = `$log_cmd` if ($log_cmd);

    for my $log_line (@log_out) {
        if ($log_line =~ /Author:/) {

            my ($last_commiter) = $log_line =~ /Author: .*\<(.*)\@.*\>/;
            if (grep(/$last_commiter/, @ignore)) {
                next;
            } else {
                push @winners, $last_commiter . '@genome.wustl.edu' if defined($last_commiter);
                push @winners_without_decoration, $last_commiter;
                last;
            }
        }
    }



    # 2. most commits
    for my $file ($test_pathname, $module_pathname) {

        next if ! -f $file;

        my $user = {};

        my $blame_cmd = "/gsc/scripts/sbin/gsc-cron /gsc/bin/git blame $file";
        my @out = `$blame_cmd`;

            for my $line (@out) {
                my ($hash, $fn, $u) = split(/\s+/, $line);
                $u =~ s/\(//g;

                next if $u =~ /[A-Z]/;      # this might be a real name not username
                next if grep(/$u/, @ignore);
                $user->{$u}++;
            }

        my @sorted = sort { $user->{$b} <=> $user->{$a} } keys %$user;

        # take the first user sorted by number of lines commited,
        # unless it was also the last commiter (see above)
        for my $s (@sorted) {
            next if grep(/$s/, @winners_without_decoration);
            push @winners, $s . '@genome.wustl.edu';
            push @winners_without_decoration, $s;
            last;
        }
    }


    # 3. random apiper
    my $winners_regex = '(' . join('|', @winners_without_decoration) . ')';
    @rest = grep(!/$winners_regex/,@us);
    my $random_apiper = $us[int(rand(@rest + 1))];    
    (my $random_apiper_without_decoration = $random_apiper) =~ s/\@.*//;
    push @winners, $random_apiper;
    push @winners_without_decoration, $random_apiper_without_decoration;


    if (@winners > 1) {
        my $to_regex = '(' . join('|', @winners_without_decoration) . ')';
        @rest = grep(!/$to_regex/,@us);
    } else {
        @winners = @us; # yay!
    }

    return (\@winners, \@rest, \@winners_without_decoration);
}

