#!/usr/bin/env perl

use strict;
use warnings;
require ShipIt;
require File::Basename;

my $snapshot_version = shift @ARGV || die;

my %package_lib_map = ShipIt::package_lib_map();

my @map_params = ('find lib');

for my $package (keys %package_lib_map) {
    for my $path (@{$package_lib_map{$package}}) {
        push @map_params, qr|lib/perl/$path|;
        push @map_params, "$package/lib/$path";
    }
}

push @map_params, qr|lib/perl/Genome/xsl/|,         'genome-subject/xsl/';
push @map_params, qr|lib/perl/Genome/Model/Tools/|, 'gmt-unsorted/lib/Genome/Model/Tools/';
push @map_params, qr|lib/perl/Genome/Model/|,       'genome-model-unsorted/lib/Genome/Model/';

my @c = (
    "git merge $snapshot_version",
    ['git status -s | grep ^DD', 'git rm'],
    ['git status -s | grep ^\ U', 'git add'],
    ['git status -s | grep ^AA', 'git rm'],
    \@map_params,
    ['echo "COMMIT UNPLACED?" 1>&2; find lib -type f', 'git add'],
    ['echo "CLEANUP DIRS?" 1>&2; find lib -type d | sort -r', 'rmdir'],
    'git diff --staged --quiet || git commit -m "merge master via update_shipit script"', # commit if there are staged changes
    'git push',
);

for my $c (@c) {
    print "\n\n";
    if (ref($c) and @$c == 2) {
        # a command to get files, and a command to run on them
        run_on_files(@$c)
    }
    elsif (ref($c) and @$c > 2) {
        # a command to run get files, a regex to rename
        find_and_rename_files(@$c);
    }
    else {
        # a plain command to run
        run($c)
    }
}

sub run_on_files {
    my $f = shift;
    my $c = shift;
    print "FILES: $f\n";
    my @f = `$f`;
    print @f;
    chomp @f;
    if (@f == 0) {
        print "(none)\n";
        return;
    }
    for (@f) {
        s/^..\s+//;
    }
    my $cmd = $c . ' ' . join(" ", map { "'$_'" } @f), "\n";
    run($cmd);
}

sub find_and_rename_files {
    my $cmd_to_get_files = shift;
    my $find = shift;
    my $replace = shift;
    
    print "FILES: $cmd_to_get_files\n";
    my @f = `$cmd_to_get_files`;
    print @f;
    chomp @f;
    if (@f == 0) {
        print "(none)\n";
        return;
    }
    
    my @patterns;
    while ($find and $replace) {
        print "  RENAME: $find TO: $replace\n";
        push @patterns, $find;
    
        rename_files($find, $replace, @f);
        
        # get the next set of expressions
        $find = shift @_;
        $replace = shift @_;
    }
    
    my @f2 = `$cmd_to_get_files`;
    if (@f2) {
        print "UNMOVED FILES: @f2\n";
        print "Trying auto_move_module...\n";
        for my $f2 (@f2) {
            auto_move_module($f2);
        }
    }
}

sub rename_files {
    my $find = shift;
    my $replace = shift;
    my @files = @_;
    
    for my $o (@files) {
        next unless (-e $o);
        my $n = $o;
        $n =~ s|$find|$replace|;
        if ($n ne $o) { 
            if (-d $o) {
                if (-d $n) {
                    print "  # directory exists: $n\n";
                }
                else {
                    print "  # creating directory $n\n";
                    mkdir $n;
                }
            } 
            else { 
                my $mv;
                if (system("git ls-files --error-unmatch -- $o")) {
                    $mv = 'mv';
                } else {
                    $mv = 'git mv'
                }
                run(qq|$mv "$o" "$n"\n|); 
            }
        }
    }
}

sub auto_move_module {
    my $path = shift || die;
    
    (my $module_parent = File::Basename::dirname($path)) =~ s/lib\/perl\///;
    
    my @find_results = find_matching_packages($module_parent);

    if (@find_results == 1) {
        my $find = 'lib/perl/' . $module_parent;
        my $replace = $find_results[0];
        rename_files($find, $replace, $path);
    } elsif (@find_results) {
        print "Cannot auto_mode_module; multiple matches for $module_parent: " . join(', ', @find_results) . ".\n";
    } else {
        print "Cannot auto_mode_module; no matches for $module_parent.\n";
    }
}

sub find_matching_packages {
    my $path = shift || die;

    my $find_cmd = "find . -path './lib' -prune -o -type d -wholename '*$path' -print";
    my @find_results = qx($find_cmd);
    chomp(@find_results);
    
    return @find_results;
}

sub run {
    my $c = shift;
    print "(running...)\n";
    my $r = system $c;
    print "exit code $r\n";
    unless ($r == 0) {
        die "Command '$c' did not succeed.";
    }
}

