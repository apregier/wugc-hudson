#!/usr/bin/env perl

use strict;
use warnings;

require Fcntl::FileLock;
require File::Basename;
require IO::File;
require File::Slurp;
require Mail::Sender;
require Getopt::Long;
require Cwd;
require LWP::UserAgent;

BEGIN {
    require Cwd;
	require File::Basename;
    my $lib_dir = Cwd::abs_path(File::Basename::dirname(__FILE__) . '/../lib/');
    unless (grep { $lib_dir eq Cwd::abs_path($_) } @INC) {
        push @INC, $lib_dir;
    }
}

require Defaults;
require Snapshot;

our $BIN_DIR = File::Basename::dirname(__FILE__);

my ($help, $announce_only, $pipeline, $user, $web, $sleep_one_hour, $all, $force, $now, $test) = ('', '', '', '', '', '', '', '', '', '');
my $getoptions_rv = Getopt::Long::GetOptions(
	'help' => \$help,
	'announce-only' => \$announce_only,
	'pipeline' => \$pipeline,
	'user' => \$user,
	'web' => \$web,
	'sleep-one-hour' => \$sleep_one_hour,
	'all' => \$all,
    'force' => \$force,
    'now' => \$now,
    'test' => \$test,
);
unless($getoptions_rv) {
    exit;
}
if ( @ARGV != 1 || $help ) {;
	print help_message();
	exit;
};

# So far this is still called HUDSON_URL even though we're running Jenkins.
unless( $ENV{HUDSON_URL} || $force) {
    print STDERR "Please run the Jenkins job instead of running this manually.\n";
    exit;
}

my $success = 1;
if ( !$now != !$sleep_one_hour ) { # $a xor $b
    if ( $pipeline || $all) {
        $success = (promote('pipeline') && $success);
    }
    if ( $user || $all ) {
        $success = (promote('user') && $success);
    }
    if ( $web || $all) {
        $success = (promote('web') && $success);
    }
    if ($success) {
        exit;
    } else {
        exit 255;
    }
} else {
    print STDERR "Please specify either --now xor --sleep-one-hour.\n";
}

exit;



sub promote {
	my $symlink_name = shift;
	
	my $NEW_BUILD_IDENTIFIER = $ARGV[0];
	
    no strict 'subs';
	my $symlink_method = 'CURRENT_' . uc($symlink_name);
	my $symlink = Defaults->$symlink_method;
	
	my $OLD_BUILD_NAME = readlink($symlink);
	$OLD_BUILD_NAME =~ s/\/+$//;
	$OLD_BUILD_NAME =~ s/.*\///;
	(my $OLD_BUILD_VERSION = $OLD_BUILD_NAME) =~ s/.*(genome-\d+).*/$1/;

	(my $NEW_BUILD_NAME = "genome-$NEW_BUILD_IDENTIFIER") =~ s/genome-genome/genome/;
	(my $NEW_BUILD_VERSION = $NEW_BUILD_NAME) =~ s/.*(genome-\d+).*/$1/;
	
    no strict 'subs';
    my $announce_email_to_method = 'ANNOUNCE_' . uc($symlink_name) . '_EMAIL_TO';

    my $file_lock = Fcntl::FileLock->create(path => '/tmp/promote.lock');
    my $start_time = time;
    while (!$file_lock->lock) {
        if ((time - $start_time) >= 300) { die "Waiting on lock file for 300 seconds, exiting.\n" };
        sleep 1;
    }

	my $changes_summary_file = create_changes_summary(
	    build_name => $NEW_BUILD_NAME,
	    old_version => $OLD_BUILD_VERSION,
	    new_version => $NEW_BUILD_VERSION,
	    announce_only => $announce_only
	);
    my $changes_summary = File::Slurp::read_file($changes_summary_file);
    $file_lock->release;
    my $promote_subject = "$NEW_BUILD_NAME promoted to current/$symlink_name";

    if ( $announce_only || $sleep_one_hour || $test) {
        my $announce_subject = "Promoting $NEW_BUILD_NAME to current/$symlink_name in one hour";
        my $announce_changes_summary = "Please let us know if there are any concerns with promoting this version to current/$symlink_name.\n\n" . $changes_summary;
        if ($test) {
            print "To: " . Defaults->$announce_email_to_method . "\n";
            print "Subject: $announce_subject\n";
            print "Message:\n$announce_changes_summary\n";
        }
        else {
            send_announcement_email(to => Defaults->$announce_email_to_method, subject => $announce_subject, msg => $announce_changes_summary);
        }
    }
    
	if ( $sleep_one_hour ) {
        system("date");
        print "Sleeping for one hour before actual promote...\n";
        sleep(3600);
    }

    unless ($announce_only || $test) {
        update_symlinks(build_name => $NEW_BUILD_NAME, symlink_name => $symlink_name) || die;
        send_announcement_email(to => Defaults->$announce_email_to_method, subject => $promote_subject, msg => $changes_summary);
    }

    unlink($changes_summary_file);
	print "current/$symlink_name: " . readlink($symlink) . "\n";

	if ( $symlink_name =~ /web/ && !$announce_only) {
        return restart_web_server($NEW_BUILD_IDENTIFIER);
	}

    return 1;
}

sub help_message {
	my $help_message;
	$help_message .= "Usage:\n";
    $help_message .= "\t$0 genome-9000 --pipeline --web \t-- promotes version and announces it to apipe\n";
	$help_message .= "Options:\n";
    $help_message .= "\t--announce-only               \t\t-- only announces that promotion will occur in one hour\n";
	$help_message .= "\t--pipeline                    \t\t-- promote the current/pipeline symlink\n";
	$help_message .= "\t--user                        \t\t-- promote the current/user symlink\n";
	$help_message .= "\t--web                         \t\t-- promote the current/web symlink\n";
	return $help_message;
};

sub update_symlinks {
	my (%params) = @_;
	my $symlink_name = delete $params{symlink_name} || die;
	my $build_name = delete $params{build_name} || die;
	my $snapshot_path = Snapshot::find_snapshot($build_name);
		
	if (my @params_keys = keys %params) {
		die "Invalid params passed to promote_symlinks: '" . join(', ', @params_keys) . "'\n";
	}
	
	if ( $symlink_name =~ /pipeline/ ) {
		print "Changing pipeline symlink ($build_name)\n";
		system("ln -sf $snapshot_path " . Defaults::CURRENT_PIPELINE() . "-new");
		system("mv -Tf " . Defaults::CURRENT_PIPELINE() . "-new " . Defaults::CURRENT_PIPELINE());
	}
	
	if ( $symlink_name =~ /web/ ) {
		print "Changing web symlink ($build_name, needs a restart)\n";
		system("ln -sf $snapshot_path " . Defaults::CURRENT_WEB() . "-new");
		system("mv -Tf " . Defaults::CURRENT_WEB() . "-new " . Defaults::CURRENT_WEB());
	}
	
    if ( $symlink_name =~ /user/ ) {
      print "Changing user symlink ($build_name)\n";
      system("ln -sf $snapshot_path " . Defaults::CURRENT_USER() . "-new");
      system("mv -Tf " . Defaults::CURRENT_USER() . "-new " . Defaults::CURRENT_USER());
    }

	return 1;
}

sub create_changes_summary {
	my (%params) = @_;
	my $build_name = delete $params{build_name} || die;
	my $old_version = delete $params{old_version} || die;
	my $new_version = delete $params{new_version} || die;
    my $announce_only = delete $params{announce_only};
	my $snapshot_path = Snapshot::find_snapshot($build_name);
    my $previous_version_file = "$snapshot_path/previous_version.txt";

    if (not $announce_only and not -s $previous_version_file) {
        system("echo $old_version >> $snapshot_path/previous_version.txt")
    }
    if (-s $previous_version_file and $new_version =~ /genome-\d+-fix\d+/) {
        chomp($old_version = qx[cat $snapshot_path/previous_version.txt]);
    }
	(my $old_git_version = $old_version) =~ s/.*(genome-\d+).*/$1/;
	(my $new_git_version = $new_version) =~ s/.*(genome-\d+).*/$1/;
	
	if (my @params_keys = keys %params) {
		die "Invalid params passed to sync_snapshot_to_lib_perl: '" . join(', ', @params_keys) . "'\n";
	}
	

	# create git-changelog
    my $git_changelog_lock_file = "/tmp/changelog.lock";
    if (-e $git_changelog_lock_file) {
        my $start_time = time;
        while (-e $git_changelog_lock_file) {
            die "Waited on changelog lock file for a minute; exiting. Verify lock is valid or remove ($git_changelog_lock_file).\n" if ((time - $start_time) >= 60);
            sleep 1;
        }
    }
    else {
        system("touch $git_changelog_lock_file");
    }

    system("$BIN_DIR/changelog $old_git_version $new_git_version > $snapshot_path/git-changelog");


	# create CHANGE_SUMMARY
	unlink("$snapshot_path/CHANGE_SUMMARY");
	my @change_summary;
	if ( -s "$snapshot_path/git-changelog" ) {
		my @git_changelog_lines = File::Slurp::read_file("$snapshot_path/git-changelog");
		push @change_summary, "== Highlighted Changes From $old_version to $new_version ==\n\n", @git_changelog_lines;
	}

    unlink $git_changelog_lock_file;

	if ( -s "$snapshot_path/hotfixes" ) {
		my @hotfixes_lines = File::Slurp::read_file("$snapshot_path/hotfixes");
		my @hotfixes_reasons = grep { $_ =~ /^Fix/ } @hotfixes_lines;
		my @hotfixes_details = grep { $_ !~ /^Fix/ } @hotfixes_lines;
		unshift @change_summary, "== Hotfix History ==\n\n", @hotfixes_reasons, "\n";
		push @change_summary, "== Hotfix Commit Details ==\n\n", @hotfixes_details;
	}
    if (@change_summary == 0) {
        push @change_summary, "No changes highlighted.\n\n";
    }

	push @change_summary, "== Disclaimer ==\n\n", "This is a summary of highlighted changes since $old_version and any hotfixes made to $new_version. For a more exhaustive list try 'git log $old_git_version..$new_git_version'.\n";
	File::Slurp::write_file("$snapshot_path/CHANGE_SUMMARY", @change_summary);
	return "$snapshot_path/CHANGE_SUMMARY";
}

sub send_announcement_email {
	my (%params) = @_;
	my $mail_to = delete $params{to} || die;
	my $mail_subject = delete $params{subject} || die;
	my $mail_msg = delete $params{msg} || die;
	
	if (my @params_keys = keys %params) {
		die "Invalid params passed to send_announcement_email: " . join(', ', @params_keys) . ".\n";
	}
	
	my $user_name = getpwuid($<);
	my $mail_from = $user_name . '@genome.wustl.edu';
	
    my $sender = Mail::Sender->new({
        smtp => 'gscsmtp.wustl.edu',
        from => $mail_from,
    });
    $sender->MailMsg({
        to => $mail_to,
        subject => $mail_subject,
        msg     => $mail_msg,
    });
	print "Sent annnouncement mail to $mail_to...\n";
    return 1;
};

sub restart_web_server {
    my $snapshot_version = shift;

    reload_genome_view();
    my $restart_succeeded = wait_for_valid_http_response($snapshot_version);
    unless ($restart_succeeded) {
        print "\n\nReload failed so attempting a stop and start.\n\n";
        return unless stop_genome_view();
        return unless start_genome_view();
        $restart_succeeded = wait_for_valid_http_response($snapshot_version);
    }

    return $restart_succeeded;
}

sub wait_for_valid_http_response {
    my $snapshot_version = shift;
    my $start_time = time;
    my $max_elapsed_seconds = 120;

    my $url = 'https://imp.gsc.wustl.edu/view/genome/search/status.html';

    my $user_agent = LWP::UserAgent->new(timeout => 10);
    if ($user_agent->can('ssl_opts')) {
        $user_agent->ssl_opts(verify_hostname => 0);
    }

    my $response;
    do {
        $response = $user_agent->get($url);
        sleep(3);
    } until (valid_http_response($response, $snapshot_version) || (time - $start_time) >= $max_elapsed_seconds);

    return valid_http_response($response, $snapshot_version);
}

sub valid_http_response {
    my $response = shift || return;
    my $snapshot_version = shift || die;

    my $code = $response->code;
    my $snapshot_path = Snapshot::find_snapshot($snapshot_version);

    if ($response->is_success) {
        my @content = split("\n", $response->decoded_content);
        if ( grep { $_ =~ /^<!-- Genome: $snapshot_path\/lib\/perl\/Genome.pm-->$/ } @content ) {
            print "OK: Web server is up (HTTP $code) on new version ($snapshot_version).\n";
            return 1;
        }
        else {
            print "Not OK: Web server is up (HTTP $code) but *not* on new version ($snapshot_version).\n";
            return;
        }
    }
    else {
        print "Not OK: Failed to get successful response (HTTP $code) from URL (". $response->filename . ").\n";
        return;
    }
}

sub reload_genome_view {
    my $reload_genome_view_cmd = "ssh -t apipe sudo /etc/init.d/genome_view reload";
    print "RUNNING ($reload_genome_view_cmd)...\n";
    my $exit_code = system("$reload_genome_view_cmd");
    if ($exit_code != 0) {
        print "Command ($reload_genome_view_cmd) did not succeed.\n";
        return;
    }
    return 1;
}

sub stop_genome_view {
    my $stop_genome_view_cmd = "ssh -t apipe sudo /etc/init.d/genome_view stop";
    print "RUNNING ($stop_genome_view_cmd)...\n";
    my $exit_code = system("$stop_genome_view_cmd");
    if ($exit_code != 0) {
        print "Command ($stop_genome_view_cmd) did not succeed.\n";
        return;
    }
    return 1;
}

sub start_genome_view {
    my $start_genome_view_cmd = "ssh -t apipe sudo /etc/init.d/genome_view start";
    print "RUNNING ($start_genome_view_cmd)...\n";
    my $exit_code = system("$start_genome_view_cmd");
    if ($exit_code != 0) {
        print "Command ($start_genome_view_cmd) did not succeed.\n";
        return;
    }
    return 1;
}
