#!/usr/bin/env perl

use strict;
use warnings;

require File::Basename;
require IO::File;
require File::Slurp;
require Mail::Sender;
require Getopt::Long;
require Cwd;

BEGIN {
    require Cwd;
	require File::Basename;
    my $lib_dir = Cwd::abs_path(File::Basename::dirname(__FILE__) . '/../lib/');
    unless (grep { $lib_dir eq Cwd::abs_path($_) } @INC) {
        push @INC, $lib_dir;
    }
}

require Defaults;
require Snapshot;

our $BIN_DIR = File::Basename::dirname(__FILE__);

my ($help, $announce_only, $pipeline, $user, $web, $sleep_one_hour, $all, $force, $now) = ('', '', '', '', '', '', '', '', '');
my $getoptions_rv = Getopt::Long::GetOptions(
	'help' => \$help,
	'announce-only' => \$announce_only,
	'pipeline' => \$pipeline,
	'user' => \$user,
	'web' => \$web,
	'sleep-one-hour' => \$sleep_one_hour,
	'all' => \$all,
    'force' => \$force,
    'now' => \$now,
);
unless($getoptions_rv) {
    exit;
}
if ( @ARGV != 1 || $help ) {;
	print help_message();
	exit;
};

unless( $ENV{HUDSON_URL} || $force) {
    print STDERR "Please run the hudson job instead of running this manually.\n";
    exit;
}

my $success = 1;
if ( !$now != !$sleep_one_hour ) { # $a xor $b
    if ( $pipeline || $all) {
        $success = (promote('pipeline') && $success);
    }
    if ( $user || $all ) {
        $success = (promote('user') && $success);
    }
    if ( $web || $all) {
        $success = (promote('web') && $success);
    }
    if ($success) {
        exit;
    } else {
        exit 255;
    }
} else {
    print STDERR "Please specify either --now xor --sleep-one-hour.\n";
}

exit;



sub promote {
	my $symlink_name = shift;
	
	my $NEW_BUILD_IDENTIFIER = $ARGV[0];
	
    no strict 'subs';
	my $symlink_method = 'CURRENT_' . uc($symlink_name);
	my $symlink = Defaults->$symlink_method;
	
	my $OLD_BUILD_NAME = readlink($symlink);
	$OLD_BUILD_NAME =~ s/\/+$//;
	$OLD_BUILD_NAME =~ s/.*\///;
	(my $OLD_BUILD_VERSION = $OLD_BUILD_NAME) =~ s/.*(genome-\d+).*/$1/;

	(my $NEW_BUILD_NAME = "genome-$NEW_BUILD_IDENTIFIER") =~ s/genome-genome/genome/;
	(my $NEW_BUILD_VERSION = $NEW_BUILD_NAME) =~ s/.*(genome-\d+).*/$1/;
	
    no strict 'subs';
    my $announce_email_to_method = 'ANNOUNCE_' . uc($symlink_name) . '_EMAIL_TO';

    my $lock_file = "/tmp/promote.lock";
    if (-e $lock_file) {
        my $start_time = time;
        while (-e $lock_file) {
            die "Waiting on lock file for 300 seconds, exiting. Verify lock is valid or remove ($lock_file).\n" if ((time - $start_time) >= 300);
            sleep 1;
        }
    }
    else {
        system("touch $lock_file");
    }

	my $changes_summary_file = create_changes_summary(
	    build_name => $NEW_BUILD_NAME,
	    old_version => $OLD_BUILD_VERSION,
	    new_version => $NEW_BUILD_VERSION,
	    announce_only => $announce_only
	);
    my $changes_summary = File::Slurp::read_file($changes_summary_file);
    system("rm -f $lock_file");
    my $promote_subject = "$NEW_BUILD_NAME promoted to current/$symlink_name";

    if ( $announce_only || $sleep_one_hour ) {
        my $announce_subject = "Promoting $NEW_BUILD_NAME to current/$symlink_name in one hour";
        my $announce_changes_summary = "Please let us know if there are any concerns with promoting this version to current/$symlink_name.\n\n" . $changes_summary;
        send_announcement_email(to => Defaults->$announce_email_to_method, subject => $announce_subject, msg => $announce_changes_summary);
    }
    
	if ( $sleep_one_hour ) {
        system("date");
        print "Sleeping for one hour before actual promote...\n";
        sleep(3600);
    }

    unless ($announce_only) {
        update_symlinks(build_name => $NEW_BUILD_NAME, symlink_name => $symlink_name) || die;
        send_announcement_email(to => Defaults->$announce_email_to_method, subject => $promote_subject, msg => $changes_summary);
    }

    unlink($changes_summary_file);
	print "current/$symlink_name: " . readlink($symlink) . "\n";
	
	if ( $symlink_name =~ /web/ && !$announce_only) {
		print "*** Warning: you must restart the web server to use the new symlink! ***\n";
        return restart_web_server();
	}

    return 1;
}

sub help_message {
	my $help_message;
	$help_message .= "Usage:\n";
    $help_message .= "\t$0 genome-9000 --pipeline --web \t-- promotes version and announces it to apipe\n";
	$help_message .= "Options:\n";
    $help_message .= "\t--announce-only               \t\t-- only announces that promotion will occur in one hour\n";
	$help_message .= "\t--pipeline                    \t\t-- promote the current/pipeline symlink\n";
	$help_message .= "\t--user                        \t\t-- promote the current/user symlink\n";
	$help_message .= "\t--web                         \t\t-- promote the current/web symlink\n";
	return $help_message;
};

sub update_symlinks {
	my (%params) = @_;
	my $symlink_name = delete $params{symlink_name} || die;
	my $build_name = delete $params{build_name} || die;
	my $snapshot_path = Snapshot::find_snapshot($build_name);
		
	if (my @params_keys = keys %params) {
		die "Invalid params passed to promote_symlinks: '" . join(', ', @params_keys) . "'\n";
	}
	
	if ( $symlink_name =~ /pipeline/ ) {
		print "Changing pipeline symlink ($build_name)\n";
		system("ln -sf $snapshot_path " . Defaults::CURRENT_PIPELINE() . "-new");
		system("mv -Tf " . Defaults::CURRENT_PIPELINE() . "-new " . Defaults::CURRENT_PIPELINE());
	}
	
	if ( $symlink_name =~ /web/ ) {
		print "Changing web symlink ($build_name, needs a restart)\n";
		system("ln -sf $snapshot_path " . Defaults::CURRENT_WEB() . "-new");
		system("mv -Tf " . Defaults::CURRENT_WEB() . "-new " . Defaults::CURRENT_WEB());
	}
	
    if ( $symlink_name =~ /user/ ) {
      print "Changing user symlink ($build_name)\n";
      system("ln -sf $snapshot_path " . Defaults::CURRENT_USER() . "-new");
      system("mv -Tf " . Defaults::CURRENT_USER() . "-new " . Defaults::CURRENT_USER());
    }

	return 1;
}

sub create_changes_summary {
	my (%params) = @_;
	my $build_name = delete $params{build_name} || die;
	my $old_version = delete $params{old_version} || die;
	my $new_version = delete $params{new_version} || die;
    my $announce_only = delete $params{announce_only};
	my $snapshot_path = Snapshot::find_snapshot($build_name);
    my $previous_version_file = "$snapshot_path/previous_version.txt";

    if (not $announce_only and not -s $previous_version_file) {
        system("echo $old_version >> $snapshot_path/previous_version.txt")
    }
    if (-s $previous_version_file and $new_version =~ /genome-\d+-fix\d+/) {
        chomp($old_version = qx[cat $snapshot_path/previous_version.txt]);
    }
	(my $old_git_version = $old_version) =~ s/.*(genome-\d+).*/$1/;
	(my $new_git_version = $new_version) =~ s/.*(genome-\d+).*/$1/;
	
	if (my @params_keys = keys %params) {
		die "Invalid params passed to sync_snapshot_to_lib_perl: '" . join(', ', @params_keys) . "'\n";
	}
	
	# create git-changelog
    system("$BIN_DIR/changelog $old_git_version $new_git_version > $snapshot_path/git-changelog");

	# create CHANGE_SUMMARY
	unlink("$snapshot_path/CHANGE_SUMMARY");
	my @change_summary;
	if ( -s "$snapshot_path/git-changelog" ) {
		my @git_changelog_lines = File::Slurp::read_file("$snapshot_path/git-changelog");
		push @change_summary, "== Highlighted Changes From $old_version to $new_version ==\n\n", @git_changelog_lines;
	}
	if ( -s "$snapshot_path/hotfixes" ) {
		my @hotfixes_lines = File::Slurp::read_file("$snapshot_path/hotfixes");
		my @hotfixes_reasons = grep { $_ =~ /^Fix/ } @hotfixes_lines;
		my @hotfixes_details = grep { $_ !~ /^Fix/ } @hotfixes_lines;
		unshift @change_summary, "== Hotfix History ==\n\n", @hotfixes_reasons, "\n";
		push @change_summary, "== Hotfix Commit Details ==\n\n", @hotfixes_details;
	}
    if (@change_summary == 0) {
        push @change_summary, "No changes highlighted.\n\n";
    }

	push @change_summary, "== Disclaimer ==\n\n", "This is a summary of highlighted changes since $old_version and any hotfixes made to $new_version. For a more exhaustive list try 'git log $old_git_version..$new_git_version'.\n";
	File::Slurp::write_file("$snapshot_path/CHANGE_SUMMARY", @change_summary);
	return "$snapshot_path/CHANGE_SUMMARY";
}

sub send_announcement_email {
	my (%params) = @_;
	my $mail_to = delete $params{to} || die;
	my $mail_subject = delete $params{subject} || die;
	my $mail_msg = delete $params{msg} || die;
	
	if (my @params_keys = keys %params) {
		die "Invalid params passed to send_announcement_email: " . join(', ', @params_keys) . ".\n";
	}
	
	my $user_name = getpwuid($<);
	my $mail_from = $user_name . '@genome.wustl.edu';
	
    my $sender = Mail::Sender->new({
        smtp => 'gscsmtp.wustl.edu',
        from => $mail_from,
    });
    $sender->MailMsg({
        to => $mail_to,
        subject => $mail_subject,
        msg     => $mail_msg,
    });
	print "Sent annnouncement mail to $mail_to...\n";
    return 1;
};

sub restart_web_server {
    my $process_list_cmd = "ssh apipe ps -fu www-data | grep perl-fcgi";
    my $get_pid_cmd = "ssh apipe cat /var/run/kom_fastcgi/genome_view.pid";
    my $restart_genome_view_cmd = "ssh -t apipe sudo /etc/init.d/genome_view reload";

    chomp(my $previous_pid = qx($get_pid_cmd));
    if ($previous_pid =~ /^\d+$/) {
        print "Previous PID = $previous_pid\n";
        my @processes = qx($process_list_cmd);
        my $processes_count = scalar @processes;
        print "Previous ($processes_count) processes were ($process_list_cmd):\n" . join("\n", @processes) . "\n";
    }
    else {
        $previous_pid = '';
    }

    print "Restarting web server in 3 seconds (^C to abort)...\n";
    sleep(3);

    print "RUNNING ($restart_genome_view_cmd)...\n";
    system("$restart_genome_view_cmd && echo COMMAND SUCCEEDED || echo COMMAND FAILED");
    print "\n";

    my $current_pid;
    for (my $i = 0; $i < 60; $i++) {
        chomp($current_pid = qx(ssh apipe cat /var/run/kom_fastcgi/genome_view.pid));
        if ($current_pid !~ /^\d+$/) {
            print STDERR "Invalid current PID ($current_pid)!\n";
            return;
        }
        last if ($current_pid != $previous_pid);
        sleep(5);
    }

    if ($current_pid == $previous_pid) {
        print "ERROR: New PID is same as old PID ($current_pid).\n";
        return;
    }

    sleep(60);

    print "Current PID = $current_pid\n";
    my @current_processes = qx($process_list_cmd | grep $current_pid);
    my $current_processes_count = scalar @current_processes;
    print "Previous ($current_processes_count) processes were ($process_list_cmd | grep $current_pid):\n" . join("\n", @current_processes) . "\n";
    unless ($current_processes_count && $current_processes_count > 1) {
        print "ERROR: Failed to find processes running under new PID.\n";
        return;
    }

    return 1;
}
