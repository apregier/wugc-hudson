#!/usr/bin/env perl

use warnings;
use strict;

use above 'Genome';
use above 'UR';
use File::Basename;
use Getopt::Long;
use Data::Dumper;

BEGIN {
    require Cwd;
    require File::Basename;
    my $lib_dir = Cwd::abs_path(File::Basename::dirname(__FILE__) . '/../lib/');
    unless (grep { $lib_dir eq Cwd::abs_path($_) } @INC) {
        unshift @INC, $lib_dir;
    }
}

use Users;
use Library;
use Revision;


my $LOOP_SLEEP_MINS = 1;
my $TIMEOUT_HOURS = 30;

$ENV{UR_COMMAND_DUMP_STATUS_MESSAGES} = 1;

sub help_and_exit {
    my ($ret_val) = @_;
    my $filename = basename(__FILE__);
    print <<EOS;
Usage: $filename [options] --model-name=name_of_model

Options:
    --model-name=           name of model
    --sw-revision=          software_revision to set on the build
    --send-emails=          (true|false) send emails on failures
    --help                  prints this message

Description:
    If software-revision is not set the git hash is retrieved from
    the current git repo (assuming you're in one).

EOS
    exit 1;
}

my $model_name;
my $sw_revision;
my $send_emails;

my $r = GetOptions("model-name=s"  => \$model_name,
                   "sw-revision=s" => \$sw_revision,
                   "send-emails:s" => \$send_emails,
                   "help"          => \&help_and_exit,
                   );

help_and_exit() unless $r;

$| = 1;

die "Model name not set" unless $model_name;
my $model = Genome::Model->get(name => $model_name);
die "Model $model_name not found" unless $model;
print "Using model: " . $model->__display_name__ . "\n";

$sw_revision = Revision::get_head_rev() unless $sw_revision;

my $b;
$b = Genome::Model::Build->get(model_id => $model->id,
                               software_revision => $sw_revision,
                               status => ['Succeeded', 'Running', 'Scheduled']);

unless($b) {
    $b = Genome::Model::Build->create(model_id => $model->id, software_revision => $sw_revision) unless $b;
    die "Failed to create build for model (".$model->name.", ID: ".$model->id.")" unless ($b);
    my $build_started = $b->start();
    die "Failed to start build (" . $b->__display_name__ . ")" unless ($build_started);
}

my $commit_rv = UR::Context->commit;
die "Could not commit changes!" unless defined $commit_rv and $commit_rv == 1;

# TODO: remove all this hash stuff, we're only ever doing one model/build at a time anyway.
my %builds;
$builds{$b->id} = $b;

my %build_master_events;
foreach my $build (values %builds) {
    $build_master_events{$build->build_id} = $build->the_master_event->id;
}

my @build_ids = sort keys %builds;

# Print out information about the builds that were started so they're recorded in the Hudson raw output
print "\n\nBuilds started for models, waiting for them to finish:\n";
for my $build_id (@build_ids) {
    my $build = $builds{$build_id};
    my $model = $build->model;
    my $type_string = Library::model_class_name_to_string($model->class);
    print "\tbuild $build_id ($type_string), model " . $model->id . " (" . $model->name . ")\n";
}
print "\n";

# Record current status of each build, continue until no builds are running or the timeout limit is reached
my %failures;
my %others;
my %successes;
my ($all_done, $total_wait_time) = (0,0);
while (!$all_done) {
    $total_wait_time++;
    sleep (60 * $LOOP_SLEEP_MINS);

    # Record status of each build, count number of running builds
    my $running = 0;
    %failures = ();
    %others = ();
    %successes = ();
    foreach my $build_id (@build_ids) {
        my $build = UR::Context->current->reload("Genome::Model::Build", id=>$build_id);
        my $event = UR::Context->current->reload("Genome::Model::Event", id=>$build_master_events{$build_id});
        if ($event->event_status =~ /Failed/ or $event->event_status =~ /Crashed/) {
            $failures{$build->id} = $event->event_status;
        } elsif ($event->event_status =~ /Succeeded/) {
            $successes{$build->id} = $event->event_status;
        } elsif ($event->event_status =~ /Running/ or $event->event_status =~ /Scheduled/) {
            $running++;
            $others{$build_id} = $event->event_status;
        } else {
            $others{$build->id} = $event->event_status;
        }
    }
    $all_done = 1 if $running == 0;

    # Just so we know that the script hasn't gone belly up, and lets us know how many builds we're waiting on
    if ($total_wait_time % 10 == 0) {
        print "Waited $total_wait_time minutes for builds to finish, $running of " . scalar @build_ids . " are still running\n";
    }

    # Time to die, send email and exit
    if ($total_wait_time > ($TIMEOUT_HOURS * 60)) {
        print "Timeout period exceeded, sending email and dying!\n";

        my $msg = "The test builds have been running for more than $TIMEOUT_HOURS hours, which has been set as the timeout period. " .
            "Here are the statuses of all of the builds:\n";
        for my $hash (\%successes, \%failures, \%others) {
            for my $build_id (sort keys %{$hash}) {
                my $build = $builds{$build_id};
                my $model = $build->model;
                my $type_string = Library::model_class_name_to_string($build->model->class);
                $msg .= "Build $build_id (type $type_string), Model " . $model->id . " (" . $model->name . ") : " . $hash->{$build_id} . "\n";
            }
        }

        if (should_send_emails()){
            Library::send_mail(
                from => 'apipe-tester@genome.wustl.edu',
                to => Library::users_to_addresses(Users::apipe()),
                subject => '[fail] Build Tests Timed Out!',
                body => $msg,
            );
        }

        exit 1;
    }
}

print "Builds are done, checking statuses and sending failure emails (if necessary)\n";

# Send email to build owners and cc apipe (or just send to apipe if no owners for type are found) for every failure
if (scalar keys %failures or scalar keys %others) {
    for my $hash (\%failures, \%others) {
        for my $key (sort keys %{$hash}) {
            my $build = $builds{$key};
            my $model = $build->model;
            my $status = $hash->{$key};
            my $type_string = Library::model_class_name_to_string($build->model->class);

            print "Build $key, type $type_string, failed (status $status), sending mail\n";

            my $build_url = "https://imp.gsc.wustl.edu/view/Genome/Model/Build/status.html?id=$key";
            my $msg = "Test build $key of type $type_string finished with status $status! Model is " . $model->id . " (" . $model->name . ").\n\n" .
                "Check out the status page at $build_url and fix it!\n";

            my @to;
            my @cc;
            if (Users->can($type_string)) {
                @to = Users->$type_string;
                @cc = Users::apipe();
            } else {
                @to = Users::apipe();
                @cc = ();
            }

            if (should_send_emails()) {
                Library::send_mail(
                    from => 'apipe-tester@genome.wustl.edu',
                    to => Library::users_to_addresses(@to),
                    cc => Library::users_to_addresses(@cc),
                    subject => "[fail] test build $key failed, type $type_string",
                    body => $msg,
                );
            }
        }
    }
    exit 1;
}
else {
    print "No test build failures found!\n";
    exit 0;
}

sub should_send_emails {
    return 0 unless defined $send_emails;
    return ($send_emails =~ /^(true|yes|1|)$/i);
}

1;
