#!/usr/bin/perl

use Genome;
use Revision;
use Library;
use Users;
use Memoize qw(memoize);
use Genome::Process::Test::IntegrationTests;

use strict;
use warnings;


# flush output buffer after every write or print
local $| = 1;
Library::setup_model_process_test();
Library::set_genome_software_result_test_name();

my $process = get_initial_process();
wait_for_process($process);

UR::Context->current->reload($process);

check_process_failure($process);

diff_process($process);


# functions
sub get_timeout {
    my $DEFAULT_TIMEOUT = 6;
    my $timeout_seconds = $DEFAULT_TIMEOUT * 3600;

    return $timeout_seconds;
}

sub get_initial_process {
    if ($ENV{GENOME_SOFTWARE_RESULT_TEST_NAME}) {
        printf("GENOME_SOFTWARE_RESULT_TEST_NAME before getting process is %s\n",
            $ENV{GENOME_SOFTWARE_RESULT_TEST_NAME});
    } else {
        print "GENOME_SOFTWARE_RESULT_TEST_NAME is not set\n";
    }

    my %test_configuration = %{test_configuration()};
    my $command_class = $test_configuration{'command_class'};
    my $process_type = $test_configuration{'process_type'};

    my %command_inputs;
    while (my ($property_name, $property_id) = each %{$test_configuration{command_object_inputs}}) {
        my $property = $command_class->__meta__->properties(property_name => $property_name);
        my $type = $property->data_type;
        if ($property->is_many) {
            $command_inputs{$property_name} = [map {$type->get($_)} @$property_id];
        }
        else {
            $command_inputs{$property_name} = $type->get($property_id);
        }
    }
    my $command = $command_class->create(%command_inputs);
    $process = $command->execute;
    UR::Context->commit;
    return $process;
}

sub test_configuration {
    return Genome::Process::Test::IntegrationTests:get_process_test_configuration(process_name());
}

sub process_name {
    return 'trio_main';
}

sub wait_for_process {
    my $process = shift;

    my $timeout = get_timeout();
    printf("Monitoring process (%s) until it completes or timeout "
        . "of %s minutes is reached.\n\n", $process->id, $timeout / 60);

    my $start_time = time;
    while (!grep { $process->status eq $_ } ('Succeeded', 'Crashed')) {
        UR::Context->current->reload($process);

        my $elapsed_time = time - $start_time;
        if ($elapsed_time > $timeout) {
            printf("Process (%s) timed out after %s minutes",
                $process->id, $timeout / 60);
            Library::send_timeout_mail();
            process_view_and_exit($process);
        }

        sleep(30);
    }
}

sub check_process_failure {
    my $process = shift;

    if ($process->status eq 'Succeeded') {
        printf("Build status is %s.\n", $process->status);
    } else {
        Library::send_fail_mail();
        process_view_and_exit($process);
    }
}

sub diff_process {
    my $process = shift;

    printf('Starting diff (new process = %s)...', $process->id);
    my $diff_cmd = Genome::Process::Command::DiffBlessed->create(
        new_process => $process,
        process_name => process_name(),
    );
    unless ($diff_cmd->execute) {
        fail("Diff command failed to execute!\n");
    }

    my $has_diffs = (defined($diff_cmd->_diffs) && scalar(keys %{$diff_cmd->_diffs})) || 0;
    if ($has_diffs) {
        Library::send_diff_mail($diff_cmd);
        exit(255);
    }

}

sub process_view_and_exit {
    my $process = shift;
    my $pv_command = Genome::Process::Command::View->create(
        process => $process);
    $pv_command->execute;
    exit(255);
}

sub fail {
    if (scalar(@_) == 1) {
        print @_;
    } elsif (scalar(@_) > 1) {
        printf @_;
    } else {
        print "Failed to execute test process\n";
    }

    exit(255);
}
